; Συστήματα Μικροϋπολογιστών - Ροή Υ [6ο Εξάμηνο]
; Δημήτρης Δήμος - 031 17 165
; 2η Ομάδα Ασκήσεων
; 4η Άσκηση

; ================= ΚΥΡΙΟ ΠΡΟΓΡΑΜΜΑ (ΕΚΚΙΝΗΣΗ) =================
START:	IN 10H
	LDA 2000H
	CALL FIR	; OR0  --> 0A00H
	CALL SEC	; AND0 --> 0A01H
	CALL THI	; OR1  --> 0A02H
	CALL FORT	; AND1 --> 0A03H
	CALL XO	; XOR  --> 0A04H

	MVI B,00H	; αρχικοποίηση Β

	; Τέσσερις φορές επαναλαμβάνουμε το εξής σενάριο:
	; 1) φορτώνουμε τη θέση μνήμης που περιέχει την
	;    έξοδο μια πύλης.
	; 2) Ύστερα, μέσω του κρατουμένου, περνάμε αυτή την έξοδο
	;    από τα δεξιά στον καταχωρητή Β

	LXI H,0A04H	; θέση 0Α04Η = έξοδος XOR
	MOV A,M
	RAR
	MOV A,B	; κάνουμε την διαμόρφωση στον Α και ύστερα τον
	RAL
	MOV B,A	; αποθηκεύουμε στον Β

	LXI H,0A02H	; θέση 0Α02Η = έξοδος αριστερής OR
	MOV A,M
	RAR
	MOV A,B
	RAL
	MOV B,A

	LXI H,0A01H	; θέση 0Α01Η = έξοδος δεξιάς AND
	MOV A,M
	RAR
	MOV A,B
	RAL
	MOV B,A

	LXI H,0A00H	; θέση 0Α00Η = έξοδος δεξιάς OR
	MOV A,M
	RAR
	MOV A,B
	RAL
	MOV B,A

	MOV A,B	; προώθηση αποτελέσματος στην έξοδο
	CMA
	STA 3000H
	
	JMP START
	
; ==============================================================

; ======== ΥΠΟΡΟΥΤΙΝΑ: ΠΑΡΑΓΩΓΉ ΕΞΌΔΟΥ ΔΕΞΙΑΣ ΠΥΛΗΣ OR =========
FIR:	LXI H,0A00H	; στην 0Α00Η θα βάλουμε την έξοδο της δεξιάς OR
	MVI M,01H	; υποθέτουμε έξοδο 1

	MOV D,A	; προσωρινό σώσιμο Α
	RAR		; CY = byte 0
	JC F_1		; αν CY = 1
	RAR
	JC F_1		; ή το byte 1 = 1, τότε αφήνουμε το 1
			; στη θέση 0Α00Η όπως το βάλαμε εξαρχής
	MVI M,00H	; αλλιώς, βάλε 0 στην θέση 0Α00Η

F_1:	MOV A,D	; επαναφορά Α
	RET
; ==============================================================

; ======== ΥΠΟΡΟΥΤΙΝΑ: ΠΑΡΑΓΩΓΉ ΕΞΌΔΟΥ ΔΕΞΙΑΣ ΠΥΛΗΣ AND ========
SEC:	LXI H,0A01H	; στην 0Α01Η θα βάλουμε την έξοδο της δεξιάς AND
	MVI M,00H	; υποθέτουμε έξοδο 0

	MOV D,A	; προσωρινό σώσιμο Α
	RAR RAR
	RAR		; CY = byte 2
	JNC S_0	; αν CY = 0
	RAR
	JNC S_0	; ή το byte 3 = 0, τότε αφήνουμε το 0
			; στη θέση 0Α01Η όπως το βάλαμε εξαρχής
	MVI M,01H	; αλλιώς, βάλε 1 στην θέση 0Α01Η

S_0:	MOV A,D	; επαναφορά Α
	RET
; ==============================================================

; ====== ΥΠΟΡΟΥΤΙΝΑ: ΠΑΡΑΓΩΓΉ ΕΞΌΔΟΥ ΑΡΙΣΤΕΡΉΣ ΠΥΛΗΣ OR ========
THI:	LXI H,0A02H	; στην 0Α02Η θα βάλουμε την έξοδο της αριστερής OR
	MVI M,01H	; υποθέτουμε έξοδο 1

	MOV D,A	; προσωρινό σώσιμο Α
	RAR RAR RAR RAR
	RAR		; CY = byte 4
	JC T_1		; αν CY = 1
	RAR
	JC T_1		; ή το byte 5 = 1, τότε αφήνουμε το 1
			; στη θέση 0Α02Η όπως το βάλαμε εξαρχής
	MVI M,00H	; αλλιώς, βάλε 0 στην θέση 0Α02Η

T_1:	MOV A,D	; επαναφορά Α
	RET
; ==============================================================

; ====== ΥΠΟΡΟΥΤΙΝΑ: ΠΑΡΑΓΩΓΉ ΕΞΌΔΟΥ ΑΡΙΣΤΕΡΗΣ ΠΥΛΗΣ AND =======
FORT:	LXI H,0A03H	; στην 0Α03Η θα βάλουμε την έξοδο της αριστερής AND
	MVI M,00H	; υποθέτουμε έξοδο 0

	MOV D,A	; προσωρινό σώσιμο Α
	RAR RAR RAR RAR RAR RAR
	RAR		; CY = byte 6
	JNC F_0	; αν CY = 0
	RAR
	JNC F_0	; ή το byte 7 = 0, τότε αφήνουμε το 0
			; στη θέση 0Α03Η όπως το βάλαμε εξαρχής
	MVI M,01H	; αλλιώς, βάλε 1 στην θέση 0Α03Η

F_0:	MOV A,D	; επαναφορά Α
	RET
; ==============================================================

; =========== ΥΠΟΡΟΥΤΙΝΑ: ΠΑΡΑΓΩΓΉ ΕΞΌΔΟΥ ΠΥΛΗΣ XOR ============
XO:	LXI H,0A03H
	MOV B,M	; Β <-- έξοδος της αριστερής AND
	LXI H,0A02H
	MOV C,M	; C <-- έξοδος της αριστερής OR
	
	LXI H,0A04H	; στην 0Α04Η θα βάλουμε την έξοδο της XOR
	MVI M,00H	; υποθέτουμε έξοδο 0

	MOV D,A	; προσωρινό σώσιμο Α
	MOV A,B
	ADI 00H
	JZ B_0		; αν Β = 0
	JMP B_1	; αν Β = 1

	; αν έφτασε σε αυτό το σημείο του κώδικα, τότε Β = 0
B_0:	MOV A,C
	ADI 00H
	JZ XO_0	; αν C = 0 τέλος (παραμένει η αρχική υπόθεση)
	MVI M,01H	; αν C = 1 άλλαξε την έξοδο σε 1 και τέλος
	JMP XO_0

	; αν έφτασε σε αυτό το σημείο του κώδικα, τότε Β = 1
B_1:	MOV A,C	
	ADI 00H
	JNZ XO_0	; αν C = 1 τέλος (παραμένει η αρχική υπόθεση)
	MVI M,01H	; αν C = 0 1 άλλαξε την έξοδο σε 1 και τέλος
	JMP XO_0

XO_0:	MOV A,D	; επαναφορά Α
	RET
; ==============================================================
	END
